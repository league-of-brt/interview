# 谈谈你对Redis主从同步的理解

* [谈谈你对Redis主从同步的理解](#谈谈你对redis主从同步的理解)
  * [1 有啥用](#1-有啥用)
  * [2 主从同步最终一致性](#2-主从同步最终一致性)
  * [3 主从复制实现原理](#3-主从复制实现原理)
    * [3\.1 同步](#31-同步)
    * [3\.2 命令传播](#32-命令传播)
  * [4 全量复制和部分复制](#4-全量复制和部分复制)
    * [4\.1 全量复制](#41-全量复制)
    * [4\.2 部分复制](#42-部分复制)
      * [4\.2\.1 复制偏移量](#421-复制偏移量)
      * [4\.2\.2 复制积压缓冲区](#422-复制积压缓冲区)
      * [4\.2\.3 节点运行ID（runid）](#423-节点运行idrunid)
  * [5 psync命令的执行](#5-psync命令的执行)
  * [6 心跳机制](#6-心跳机制)
    * [6\.1 检查主从节点的网络连接状态](#61-检查主从节点的网络连接状态)
    * [6\.2 检测命令丢失](#62-检测命令丢失)
    * [6\.3 辅助实现min\-slaves选项](#63-辅助实现min-slaves选项)
  * [7 实际问题](#7-实际问题)
    * [7\.1 故障超时问题](#71-故障超时问题)
    * [7\.2 实际的坑](#72-实际的坑)

参考：
1. https://zhuanlan.zhihu.com/p/151740247
2. https://phachon.com/redis/redis-1.html

## 1 有啥用

1. 数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。
2. 故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。
3. 负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis的并发量。
4. 高可用基石：主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。

## 2 主从同步最终一致性

首先要懂什么叫CAP，然后就知道了Redis的主从同步是AP，为了可用性必须牺牲一部分一致性。但是Redis可以保障最终一致性。

怎么保证最终一致性呢？

Redis的从节点会努力追赶主节点。如果网络断开了，主从节点的数据将会出现大量不一致，一旦网络恢复，从节点会采用多种策略努力追赶上落后的数据，继续尽力保持和主节点一致。

## 3 主从复制实现原理

有6个步骤：

1. 设置主节点的地址和端口
2. 建立套接字连接
3. 发送PING命令
4. 权限验证
5. 同步
6. 命令传播

前4个步骤应该都好理解：

1. 确定主从关系
2. 建立连接
3. 确定连接可靠
4. 是否有权限同步

### 3.1 同步

同步就是将从节点的数据库状态更新成主节点当前的数据库状态。

具体执行的方式是：从节点向主节点发送psync命令（Redis2.8以前是sync命令），开始同步。

数据同步阶段是主从复制最核心的阶段，根据主从节点当前状态的不同，可以分为全量复制和部分复制。

### 3.2 命令传播

经过上面同步操作，此时主从的数据库状态其实已经一致了，但这种一致的状态的并不是一成不变的。

在完成同步之后，也许主节点马上就接受到了新的写命令，执行完该命令后，主从的数据库状态又不一致。

> 数据同步阶段完成后，主从节点进入命令传播阶段；在这个阶段主节点将自己执行的写命令发送给从节点，从节点接收命令并执行，从而保证主从节点数据的一致性。
>
> **个人认为：在命令传播阶段，同步信息是主节点主动推送的。**

命令传播是异步的过程，即主节点发送写命令后并不会等待从节点的回复；因此实际上主从节点之间很难保持实时的一致性，延迟在所难免。数据不一致的程度，与主从节点之间的网络状况、主节点写命令的执行频率、以及主节点中的 repl-disable-tcp-nodelay 配置等有关。

repl-disable-tcp-nodelay 有两个选项：
1. yes
2. no

作用分别为：

1. 主节点发生写命令，我们把一些写命令合在一起发，这样能节省同步带宽，但是会造成同步延迟。
2. 主节点发生写命令，马上通知从节点去同步。

总之，前者注重一致性，后者更关注性能。

总之，要记住在在命令传播阶段，同步信息是主节点主动推送的。

## 4 全量复制和部分复制

在Redis2.8以前，从节点向主节点发送sync命令请求同步数据，此时的同步方式是全量复制；在Redis2.8及以后，从节点可以发送psync命令请求同步数据，此时根据主从节点当前状态的不同，同步方式可能是全量复制或部分复制。

1. 全量复制：用于初次复制或其他无法进行部分复制的情况，将主节点中的所有数据都发送给从节点，是一个非常重型的操作。

2. 部分复制：用于网络中断等情况后的复制，只将中断期间主节点执行的写命令发送给从节点，与全量复制相比更加高效。需要注意的是，如果网络中断时间过长，导致主节点没有能够完整地保存中断期间执行的写命令，则无法进行部分复制，仍使用全量复制。

### 4.1 全量复制

> 1. 从节点判断无法进行部分复制，向主节点发送全量复制的请求；或从节点发送部分复制的请求，但主节点判断无法进行部分复制；具体判断过程需要在讲述了部分复制原理后再介绍。
> 
> 2. 主节点收到全量复制的命令后，执行bgsave，在后台生成RDB文件，并使用一个缓冲区（称为复制缓冲区）记录从现在开始执行的所有写命令
> 
> 3. 主节点的bgsave执行完成后，将RDB文件发送给从节点；从节点首先清除自己的旧数据，然后载入接收的RDB文件，将数据库状态更新至主节点执行bgsave时的数据库状态
> 
> 4. 主节点将前述复制缓冲区中的所有写命令发送给从节点，从节点执行这些写命令，将数据库状态更新至主节点的最新状态
> 
> 5. 如果从节点开启了AOF，则会触发bgrewriteaof的执行，从而保证AOF文件更新至主节点的最新状态

现在我们知道全量复制需要使用到RDB，那么全量复制的缺点基本上就是RDB的缺点：

1. 主节点使用bgsave非常消耗性能，需要fork子进程，备份过程消耗内存、CPU和磁盘IO。

2. RDB文件是主节点全量数据大小，通过网络把RDB文件发送给从节点，会消耗很多带宽，延迟也高。

3. 从节点清空旧数据，载入新的RDB文件，过程是阻塞的，没有办法响应客户端命令。如果从节点开启了AOF，那还要额外去写AOF文件，那消耗就更多。

### 4.2 部分复制

部分复制的实现，依赖于三个重要的概念：

1. 复制偏移量
2. 复制积压缓冲区
3. 节点运行ID（runid）

#### 4.2.1 复制偏移量

执行复制的双方，主从节点，分别会维护一个复制偏移量offset： 主节点每次向从节点同步了N字节数据后，将修改自己的复制偏移量offset+N。

从节点每次从主节点同步了N字节数据后，将修改自己的复制偏移量offset+N。

offset用于判断主从节点的数据库状态是否一致：
1. 如果二者offset相同，则一致；
2. 如果offset不同，则不一致，此时可以根据两个offset找出从节点缺少的那部分数据。

例如，如果主节点的offset是1000，而从节点的offset是500，那么部分复制就需要将offset为501-1000的数据传递给从节点。

#### 4.2.2 复制积压缓冲区

上面例子中的offset为501-1000的数据存储的位置，就是复制积压缓冲区。

主节点内部维护了一个固定长度的、先进先出(FIFO)队列 作为复制积压缓冲区，其默认大小为1MB。

在主节点进行命令传播时，不仅会将写命令同步到从节点，还会将写命令写入复制积压缓冲区。

> 由于复制积压缓冲区定长且是先进先出，所以它保存的是主节点最近执行的写命令；时间较早的写命令会被挤出缓冲区。因此，当主从节点offset的差距过大超过缓冲区长度时，将无法执行部分复制，只能执行全量复制。

从节点将offset发送给主节点后，主节点根据offset和缓冲区大小决定能否执行部分复制：

1. 如果offset偏移量之后的数据，仍然都在复制积压缓冲区里，则执行部分复制；

2. 如果offset偏移量之后的数据已不在复制积压缓冲区中（数据已被挤出），则执行全量复制。

> 我们都知道部分复制比较节省性能，为了提高网络中断时部分复制执行的概率，可以根据需要增大复制积压缓冲区的大小(通过配置repl-backlog-size)；例如如果网络中断的平均时间是60s，而主节点平均每秒产生的写命令(特定协议格式)所占的字节数为100KB，则复制积压缓冲区的平均需求为6MB，保险起见，可以设置为12MB，来保证绝大多数断线情况都可以使用部分复制。

#### 4.2.3 节点运行ID（runid）

主节点没办法知道一个从节点是新连接还是重新连接，

每个Redis节点，都有其运行ID，运行ID由节点在启动时自动生成，主节点会将自己的运行ID发送给从节点，从节点会将主节点的运行ID存起来。

从节点Redis断开重连的时候，就是根据运行ID来判断同步的进度：

1. 如果从节点保存的runid与主节点现在的runid相同，说明主从节点之前同步过，主节点会继续尝试使用部分复制(到底能不能部分复制还要看offset和复制积压缓冲区的情况)；

2. 如果从节点保存的runid与主节点现在的runid不同，说明从节点在断线前同步的Redis节点并不是当前的主节点，只能进行全量复制。

## 5 psync命令的执行

现在我们知道了同步是怎么实现的：

1. 复制偏移量
2. 复制积压缓冲区
3. 节点运行ID（runid）

接下来我们应该知道，主从节点之间是如何决定使用全量复制还是部分复制的。

![pic](https://brt-1303999354.cos.ap-shanghai.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20210404012929.png)

## 6 心跳机制

心跳检测机制的作用有三个：

1. 检查主从节点的网络连接状态
2. 检测命令丢失
3. 辅助实现min-slaves选项

### 6.1 检查主从节点的网络连接状态

每次心跳，主节点都可以拿到从节点的连接信息：

主节点信息中可以看到所属的从节点的连接信息：

1. state 表示从节点状态
2. offset 表示复制偏移量
3. lag 表示延迟值（几秒之前有过心跳检测机制）

### 6.2 检测命令丢失

每次心跳，在从节点的连接信息中可以看到复制偏移量。

假如在主从同步过程中数据丢了，那么主节点的复制偏移量就会和从节点的复制偏移量不一致。

这就是命令丢失，主节点会补发缺失的数据。和命令传播阶段一样，补发行为是主节点主动去推送的。

### 6.3 辅助实现min-slaves选项

min-slaves是配置，保证主节点必须包含从节点。如果主从节点达不到一定条件，主节点都会拒绝执行写命令。

1. min-slaves-to-write 3（可用从节点小于3个会拒绝服务）
2. 延迟值 min-slaves-max-lag 10（3个从节点的复制同步延迟超过10s会拒绝服务）

这两个配置可以防止主从节点的数据差异过大。

## 7 实际问题

1. 延迟和不一致问题
2. 数据过期问题
3. 故障切换问题
4. 故障超时问题

### 7.1 故障超时问题

在复制连接建立过程中及之后，主从节点都有机制判断连接是否超时，其意义在于：

1. 如果主节点判断连接超时，其会释放相应从节点的连接，从而释放各种资源，否则无效的从节点仍会占用主节点的各种资源（输出缓冲区、带宽、连接等）；此外连接超时的判断可以让主节点更准确的知道当前有效从节点的个数，有助于保证数据安全（配合前面讲到的min-slaves-to-write等参数）。

2. 如果从节点判断连接超时，则可以及时重新建立连接，避免与主节点数据长期的不一致。

### 7.2 实际的坑

> 1. 数据同步阶段：在主从节点进行全量复制bgsave时，主节点需要首先fork子进程将当前数据保存到RDB文件中，然后再将RDB文件通过网络传输到从节点。如果RDB文件过大，主节点在fork子进程+保存RDB文件时耗时过多，可能会导致从节点长时间收不到数据而触发超时；此时从节点会重连主节点，然后再次全量复制，再次超时，再次重连……这是个悲伤的循环。为了避免这种情况的发生，除了注意Redis单机数据量不要过大，另一方面就是适当增大repl-timeout值，具体的大小可以根据bgsave耗时来调整。
> 
> 2. 命令传播阶段：如前所述，在该阶段主节点会向从节点发送PING命令，频率由repl-ping-slave-period控制；该参数应明显小于repl-timeout值(后者至少是前者的几倍)。否则，如果两个参数相等或接近，网络抖动导致个别PING命令丢失，此时恰巧主节点也没有向从节点发送数据，则从节点很容易判断超时。
> 
> 3. 慢查询导致的阻塞：如果主节点或从节点执行了一些慢查询（如keys *或者对大数据的hgetall等），导致节点阻塞；阻塞期间无法响应复制连接中对方节点的请求，可能导致复制超时。
