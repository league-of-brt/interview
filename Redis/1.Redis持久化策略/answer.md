# 谈谈你对Redis数据持久化的理解？

* [谈谈你对Redis数据持久化的理解？](#谈谈你对redis数据持久化的理解)
  * [1 Redis持久化发展路线](#1-redis持久化发展路线)
  * [2 RDB](#2-rdb)
    * [2\.1 rdb文件的落地](#21-rdb文件的落地)
      * [2\.1\.1 手动触发](#211-手动触发)
        * [2\.1\.1\.1 SAVE](#2111-save)
        * [2\.1\.1\.2 BGSAVE](#2112-bgsave)
        * [2\.1\.1\.3 SAVE和BGSAVE的对比](#2113-save和bgsave的对比)
      * [2\.1\.2 自动触发](#212-自动触发)
    * [2\.2 rdb文件的载入](#22-rdb文件的载入)
    * [2\.3 RDB的优点](#23-rdb的优点)
    * [2\.4 RDB的缺点](#24-rdb的缺点)
  * [3 AOF](#3-aof)
    * [3\.1 为什么会落地失败？](#31-为什么会落地失败)
    * [3\.2 aof落地策略](#32-aof落地策略)
    * [3\.3 AOF重写](#33-aof重写)
      * [3\.3\.1 手动触发](#331-手动触发)
      * [3\.3\.2 自动触发](#332-自动触发)
      * [3\.3\.3 压缩机制](#333-压缩机制)
      * [3\.3\.4 重写过程](#334-重写过程)
      * [3\.3\.5 AOF的优点](#335-aof的优点)
      * [3\.3\.6 AOF的缺点](#336-aof的缺点)
  * [4 RDB和AOF对比](#4-rdb和aof对比)
  * [5 技术选型](#5-技术选型)
    * [5\.1 数据库缓存](#51-数据库缓存)
    * [5\.2 单机环境](#52-单机环境)
    * [5\.3 主从部署](#53-主从部署)
    * [5\.4 异地备灾](#54-异地备灾)

首先你应该通读官方持久化文档：https://redis.io/topics/persistence

已经介绍了很多情况，但是略嫌不够详细。

## 1 Redis持久化发展路线

发现问题，解决问题，循环。

1. 一开始没有备份，一断电或者崩溃，内存数据全部丢失。
2. 加入手动全量备份机制，推出SAVE，同步阻塞。
3. 尝试解决阻塞问题，推出BGSAVE，只有fork时会阻塞。
4. 增加自动备份配置，符合配置自动BGSAVE。
5. RDB备份间隔时间太长，容易丢数据。推出增量备份。
6. 增量备份文件太大，尝试进行文件重写，减少文件体积。

其中某些解决问题的思路是值得我们借鉴的。

## 2 RDB

Redis默认通过RDB方式完成持久化，将内存中的数据生成快照保存到磁盘里面，保存的文件后缀是.rdb。

rdb文件是一个经过压缩的二进制文件，当Redis重新启动时，可以读取rdb快照文件恢复数据。

RDB功能最核心的是`rdbSave`和`rdbLoad`两个函数，前者用于生成rdb文件并保存到磁盘，而后者则用于将rdb文件中的数据重新载入到内存中。

![pic](https://brt-1303999354.cos.ap-shanghai.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20210310153307.png)

**rdb文件是一个单文件的全量数据**，很适合数据的容灾备份与恢复。

通过rdb文件恢复数据库耗时较短，通常1G的快照文件载入内存只需20s左右。

### 2.1 rdb文件的落地

redis.conf文件的配置项如下：

Redis提供了手动触发保存、自动保存间隔两种rdb文件的生成方式。

#### 2.1.1 手动触发

##### 2.1.1.1 SAVE

SAVE是一个同步命令，它会阻塞所有客户端的请求，直到rdb文件创建完成为止（实际上这里也不是所有命令都会阻塞，如果再次执行SAVE和BGSAVE，会直接返回，因为不允许用重复的备份子进程）。

RDB过程完成之后，会替换掉旧的rdb文件。

该方法已经被废弃，线上不建议使用。

##### 2.1.1.2 BGSAVE

BGSAVE是一个异步命令，执行该命令时，Redis主进程会去检查子进程中是否存在AOF或者其他RDB的子进程，如果存在，说明正在备份，命令直接返回。如果不存在，那么主进程fork出一个RDB子进程，异步进行全量备份。主进程继续处理请求。

![pic](https://brt-1303999354.cos.ap-shanghai.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20210310160137.png)


1. 客户端发起BGSAVE命令，主进程判断当前是否存在正在执行备份的子进程，如果存在则直接返回。
2. 父进程fork一个子进程，**fork的过程中会造成阻塞的情况**，这个过程可以使用info stats 命令查看latest_fork_usec选项，查看最近一次fork操作消耗的时间，单位是微秒。
3. 父进程fork完成之后，则会返回Background saving started的信息提示，此时fork阻塞解除。
4. fork创建的子进程开始根据父进程的内存数据生成临时的快照文件，然后替换原文件（重命名）。
5. 子进程备份完毕后向父进程发送完成信息，父进程更新统计信息。

##### 2.1.1.3 SAVE和BGSAVE的对比

|命令|SAVE|BGSAVE|
|----|----|----|
|IO类型|同步|异步|
|阻塞时机|全程阻塞|fork阶段阻塞|
|复杂度|O(n)|O(n)|
|优点|不会消耗额外内存|不阻塞客户端|
|缺点|阻塞所有客户端|fork进程消耗额外内存|

#### 2.1.2 自动触发

因为BGSAVE命令可以在不阻塞服务器进程的情况下执行，所以Redis的配置文件redis.conf提供了一个save选项。

用户可以通过save选项设置多个保存条件。Redis服务器会周期性地操作serverCron函数，这个函数每隔100毫秒执行一次，它的一项任务就是检查save选项所设置的保存条件是否满足。

只要其中任意一个条件被满足，服务器就会执行BGSAVE命令。

redis.conf默认配置为：

```bash
save 900 1     # 900秒（15分钟）内有1个写入
save 300 10    # 300秒（5分钟）内有10个写入
save 60 10000  # 60秒（1分钟）内有10000个写入
```

### 2.2 rdb文件的载入

和使用SAVE和BGSAVE命令创建rdb文件不同，Redis没有专门提供用于载入rdb文件的命令。

rdb文件的载入过程是在Redis服务器启动时自动完成的。启动时只要在指定目录检测到rdb文件的存在，就会通过rdbLoad函数自动载入rdb文件。

但是这里有个限制，如果Redis已经开启了AOF备份，并且成功备份了aof文件，Redis会优先使用aof文件去恢复数据库状态。

为什么？

1. aof文件属于增量命令备份，rdb文件属于全量数据备份，一般来说aof文件更小，更新效率更高。
2. aof文件备份频率高于rdb文件，相对来说数据会更新。

### 2.3 RDB的优点

1. rdb是一个紧凑压缩的二进制文件，代表Redis在某个时间点上的数据快照，非常适用于备份，全量复制等场景。比如每6小时执行BGSAVE备份，并把rdb文件拷贝到远程机器或者文件系统中，用于灾难恢复。
2. rdb文件存的都是数据，可以直接恢复，而aof文件记录的都是操作，需要重放。所以Redis加载rdb文件的恢复效率强于aof文件。

### 2.4 RDB的缺点

1. RDB备份数据没办法做到实时持久化/秒级持久化。因为BGSAVE每次运行都要执行fork操作创建子进程，属于重量级操作，频繁执行成本过高。
2. rdb文件使用特定二进制格式保存，Redis版本演进过程中有多个格式的RDB版本，存在老版本Redis服务无法兼容新版RDB格式的问题。

## 3 AOF

就算RDB按照周期去备份，周期依然是分钟级别的，如果请求量很大，那么肯定丢失大量数据，是不可接受的。

![pic](https://brt-1303999354.cos.ap-shanghai.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20210310234533.png)

对此，Redis参考了MySQL的binglog，每次进行写入操作，就把具体操作记录下来，专门写入一个文件，保存的文件后缀是.aof。

### 3.1 为什么会落地失败？

如果每次执行一条命令，就把具体指令记录到aof文件中，肯定会遇到严重的性能问题！

![pic](https://brt-1303999354.cos.ap-shanghai.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20210311000007.png)

假如存在1000个客户端，同时调用写入方法，那么就要写入1000次，而且每次写入都会阻塞。此时，磁盘IO就变成了aof的瓶颈，这显然是不可接受的。

对此，我们可以参考MySQL的数据落地过程，所有写入先在内存buffer中完成操作，再择机写入aof文件，我们把该buffer成为aof_buf：

![pic](https://brt-1303999354.cos.ap-shanghai.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20210311001442.png)

现在我把命令都保存到aof_buf中，然后每1s调用一次write()，这次总该大功告成了吧？就算我断电了，我也只是丢了1s的数据而已，已经把损失减到最小了！

谁知道，操作系统也是有缓存区的，aof_buf的数据没有直接写入磁盘内，而是写入了缓存区，一旦断电，这些数据还是丢了！

### 3.2 aof落地策略

> 为了提高文件的写入效率，当用户调用write()函数将数据写入文件时，操作系统会先把数据写入到一个内存缓冲区里，当缓冲区被填满或超过了指定时限后，才真正将缓冲区的数据写入到磁盘里。

![pic](https://brt-1303999354.cos.ap-shanghai.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20210311002340.png)

那么，当数据从aof_buf写到OS buffer时，还得执行一下fsync()，真正把数据写入到磁盘中。

> 虽然操作系统底层对write()函数进行了优化，但也带来了安全问题。如果宕机内存缓冲区中的数据会丢失，因此系统同时提供了同步函数fsync()，强制操作系统立刻将缓冲区中的数据写入到磁盘中，从而保证了数据持久化。

对于缓冲区的结构，我们需要了解一下这张图：

![pic](https://brt-1303999354.cos.ap-shanghai.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20210311010544.png)

那么问题来了，我们多久调用一次fsync？要知道fsync()也是会阻塞的，如果频繁调用，fsync也会成为瓶颈。

对此，Redis选择了MySQL Redolog类似的落地策略，通过appendfsync配置项来控制aof_buf的同步策略：

> * appendfsync always：每执行一次命令保存一次。
>  
> fwrite()后立即调用write()，再调用fsync()写入aof文件，操作完成后线程返回，整个过程是阻塞的。这种情况下，每次有写命令都要同步到aof文件，磁盘IO成为性能瓶颈，Redis只能支持大约几百TPS写入，严重降低性能。
>
> * appendfsync no：不保存。
>
> fwrite()后立即调用write()，write()完成后调用线程立刻返回。操作系统负责同步，通常同步周期为30秒。这种情况下，文件同步的时间不可控，且缓冲区中堆积的数据会很多，数据安全性无法保证。 
>
> * appendfsync everysec：每秒钟保存一次。
>
> fwrite()后立即调用write()，write()完成后调用线程立刻返回。fsync()由单独的进程（BIO）每秒调用一次。everysec是前述两种策略的折中，是性能和数据安全性的平衡，因此也是Redis的默认配置，是比较推崇的配置选项。

**这里的一些方法调用可能有错误，也就图一乐，具体是怎么做的要看源码。**

影响如下：

|文件同步策略|write阻塞|fsync阻塞|宕机时的数据丢失量|
|----|----|----|----|
|always|阻塞|阻塞|最多只丢失一个命令的数据|
|no|阻塞|不阻塞|未来得及fsync()的数据|
|everysec|阻塞|不阻塞|一般不超过1s的数据|

### 3.3 AOF重写

随着Redis执行命令的累积，aof文件会越来越大，不仅非常占磁盘空间，复制移动、加载分析都会特别好使。所以得想办法压缩一下aof文件，此过程被称为AOF重写。

#### 3.3.1 手动触发

直接调用BGREWRITEAOF命令，该命令的执行与BGSAVE有些类似，都是fork子进程进行具体的工作，且都只有在fork时会阻塞。

#### 3.3.2 自动触发

四个配置项决定自动触发的时机：
1. auto-aof-rewrite-min-size（执行AOF重写时，文件的最小体积，默认值为64MB）
2. auto-aof-rewrite-percentage（执行AOF重写时，aof_current_size和aof_base_size的比值）
3. aof_current_size（当前AOF大小）
4. aof_base_size（上一次重写时AOF大小）

当aof文件超过设置的大小，和比值超过一定量级，就会触发AOF重写。

#### 3.3.3 压缩机制

为什么AOF重写能减少aof文件的体积？

主要做了以下几点：

1. 过期的数据没有必要再写入aof文件。
2. 无效的命令不需要再写入aof文件，比如重复设值：set key value1, set key value2。
3. 合并多条命令，比如多条重复指令：sadd key value1，sadd key value2，可以简化为sadd key value1 value2。但是，为了防止单条命令过大造成客户端缓冲区溢出，对于list、set、hash、zset类型的key，并不一定只使用单条命令，而是以某个Redis定义的一个常量为界，将命令拆分为多条去执行。

#### 3.3.4 重写过程

重写过程必须考虑增量的处理，简单示例：

![pic](https://brt-1303999354.cos.ap-shanghai.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20210311022336.png)

很明显，这个示例里面没有考虑到增量，导致重写出来的aof文件缺少新的写入。

于是，除了aof_buf之外，Redis为了增量数据再开辟一块缓存区域aof_rewrite_buf，重写期间的增量命令都记录在这一块。

简略的重写过程：

![pic](https://brt-1303999354.cos.ap-shanghai.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20210311024453.png)

完整的重写过程：

![pic](https://brt-1303999354.cos.ap-shanghai.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20210311025038.png)

1. 客户端通过BGREWRITEAOF命令对Redis主进程发起AOF重写请求。
2. 当前不存在正在执行BGSAVE/BGREWRITEAOF的子进程时，Redis主进程通过fork操作创建子进程，这个过程主进程是阻塞的。如果发现BGREWRITEAOF子进程直接返回；如果发现BGSAVE子进程则等 BGSAVE执行完成后再执行fork操作。
3. 主进程的fork操作完成后，继续处理其他命令，把新的写命令同时追加到aof_buf和 aof_rewrite_buf中。
4. 在文件重写完成之前，主进程会继续把写命令追加到aof_buf，根据appendfsync策略同步到旧的 aof文件，这样可以避免AOF重写失败造成数据丢失，保证原有的aof文件的正确性。
5. 由于fork操作运用写时复制技术，子进程只能共享fork操作时的内存数据，主进程会把新命令追加到aof_rewrite_buf中，避免AOF重写时丢失增量数据。
6. 子进程读取Redis进程中的数据快照，生成写入命令并按照命令合并规则批量写入到新的aof文件。
7. 子进程写完新的aof文件后，向主进程发信号，主进程更新统计信息，具体可以通过info persistence查看。
8. 主进程接受到子进程的信号以后，将aof_rewrite_buf中的写命令追加到新的aof文件。
9. 主进程使用新的aof文件替换旧的aof文件，aof重写过程完成。

#### 3.3.5 AOF的优点

1. 数据更完整，安全性更高，秒级数据丢失（取决于fsync()策略，如果是everysec，最多丢失1s的数据）
2. aof文件是一个只进行追加的命令文件，且写入操作是以Redis协议的格式保存的，内容是可读的，适合误删紧急恢复。

#### 3.3.6 AOF的缺点

1. 对于相同的数据集，aof文件的体积要远远大于rdb文件，数据恢复也会比较慢。
2. 根据所使用的fsync()策略，AOF的速度可能会慢于RDB。不过在一般情况下，每秒fsync()的性能依然非常高。

## 4 RDB和AOF对比

|持久化机制|RDB|AOF|
|----|----|----|
|启动恢复优先级|低|高|
|磁盘文件体积|小|大|
|数据还原速度|快|慢|
|数据安全性|容易丢失数据|根据策略决定|
|操作轻重级别|重|轻|

## 5 技术选型

只有参考意义。

难点在于分布式环境，持久化的选择必须与Redis的主从策略一起考虑，因为主从复制与持久化同样具有数据备份的功能，而且Master和Slave可以独立选择持久化方案。

### 5.1 数据库缓存

用作缓存，重要的是性能，不能轻易崩，崩了恢复也要快。

个人认为，如果Redis（无论是单机还是集群）崩溃，流量直接打到数据库上，只有两种情况：
1. 缓存雪崩，数据库也崩。
2. 容灾做得好，数据库顶住了。

对于情况1，此时肯定先限流熔断，恢复数据库，再尽快恢复Redis，逐渐放大流量新增缓存，重新让Redis去承担压力。所以没有时间去做数据恢复，持久化意义不大。

对于情况2，反正现在数据库顶住了，就算缓存数据全丢了也没关系，只要恢复Redis，缓存慢慢起来就好。

总之，当务之急是恢复缓存，不用持久化也没关系。这也提醒我们，用于缓存的Redis（无论是单机还是集群）最好还是独立出来，不要和别的业务共享逻辑，单独做缓存。

### 5.2 单机环境

在单机环境下，如果可以接受十几分钟或更多的数据丢失，RDB对Redis的性能更加有利，但是你需要调整合适的RDB触发策略。如果只能接受秒级别的数据丢失，选择AOF方案更合适。

比如一些小型的分布式环境，可能用单机Redis做分布式锁，这种情况下要尽量持久化，如果竞争激烈就选择everysec，否则always。

### 5.3 主从部署

一种可行的做法如下：

1. master：完全关闭持久化，这样可以让主节点的性能达到最好。
2. slave：关闭RDB，开启AOF（如果对数据安全要求不高，开启RDB关闭AOF也可以）。定时对持久化文件进行备份（如备份到其他文件夹，并标记好备份的时间）。关闭AOF的自动重写功能，添加定时任务，在每天Redis服务器闲时（如0点）调用BGWRITEAOF手动重写。

但是还是要具体问题具体分析：

> 案例一（master和slave同时停止）：
>
> 如果master和slave位于同一个机房，一次断电就可能导致master和 slave机器同时关机，Redis服务器进程停止。如果没有持久化，数据全丢。
>
> 如果你的slave开着AOF，master的数据没了，你可以设置slave为master，这样可能就丢个几s的数据。

> 案例二（开启了主从复制，没有设置哨兵）：
>
> 如果master节点因为故障宕机，并且系统中有自动拉起机制（即检测到服务停止后重启该服务）将master节点自动重启。
> 
> 如果你的主从有设置哨兵，master下线了会马上有slave出来顶替，那可能也就丢没主从同步的一部分数据。
>
> 如果连哨兵都没有，master重新上线之后数据是空的，slave去同步数据也都变成空的，数据全丢。

### 5.4 异地备灾

由于rdb文件文件小、恢复速度快，灾难恢复一般采用RDB。

1. 单机环境：可以定时将rdb文件或重写后的aof文件，通过scp命令拷贝到远程机器。
2. 主从部署：可以定时在master节点上执行BGSAVE操作，然后将RDB文件拷贝到远程机器，或者在 slave上执行BGWRITEAOF命令重写aof文件后，将aof文件拷贝到远程机器上。

个人觉得还是利用主从的特点，定时备份rdb文件，在异地备份机房的master去BGSAVE。这样就算出了问题，第一时间切机房，多少能减轻损失。
