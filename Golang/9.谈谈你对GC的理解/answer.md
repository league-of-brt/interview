# 谈谈你对GC的理解

https://segmentfault.com/a/1190000022030353

1. go gc 为何是非分代的？
2. go gc 为何是非紧缩的?
3. 并发三色标记扫描是什么？ 内存分配 扫描的是内存单位 √
4. go 如何实现的 并发三色标记扫描？ 
5. 强三色不变性和弱三色不变性的含义？ √
6. gc是为何需要写屏障？ 插入写、删除写 √
7. 插入写屏障和删除写屏障的时机和区别？go中如何实现的？
8. GC 的四个阶段？ √
9. 为何需要辅助标记和辅助清扫？ 
10. GC 4个阶段，STW发生在何时？ √
11. 描述下 gc 调步算法的实现？
12. 工作中gcdebug的使用？ go debug pprof √
13. gc 清扫阶段 对象回收 和 内存单元 回收 的联系和差异？ √

* 1.1 STW
* 1.3 优化STW
* 1.5 三色标记法
* 1.8 混合写屏障

## 1 STW

GC的顺序：
开始STW -> 标记垃圾对象 -> 删除垃圾对象 -> 解除STW

优化为：
开始STW -> 标记垃圾对象 -> 解除STW -> 删除垃圾对象（异步）

## 2 三色标记法，没有STW，会遇到什么问题？

悬挂指针问题。

1. 一个灰色对象A在GC期间，正好断开一个白色对象B的引用
2. 同时，一个黑色对象C引用了这个白色对象B

因为黑色对象C不会再次被扫描，所以白色对象B不会被置灰，也不会被置黑，最终被回收。那么黑色对象的一个引用就会变成空。

## 3 如何解决悬挂指针问题？

1. 强三色不变性
2. 弱三色不变性

### 3.1 强三色不变性

GC期间禁止任何的黑色对象去引用白色对象。

### 3.2 弱三色不变性

GC期间允许黑色对象引用白色对象，但是必须满足两个条件：
1. 这个白色对象直接被灰色对象引用。
2. 这个白色对象间接被灰色对象可达。

## 4 如何实现以上两种不变性？

通过内存屏障机制，分为：
1. 插入写屏障
2. 删除写屏障
3. 混合写屏障

### 4.1 插入写屏障

对象被引用时，触发的机制。

GC期间，当A对象引用B对象的时候，B对象会被标记为灰色。这是强三色不变性的应用，只要任何黑色对象引用的对象都变成灰色，就不会导致悬挂指针。

但是插入写屏障开销很大，栈上对性能要求高，所以没有插入写屏障机制，只有堆上存在。也就是说，栈上的A对象引用栈上的B对象，B对象不会被置为灰色。

如果B对象没有被置为灰色，那岂不是要被GC回收了？

在所有灰色对象被置为黑色，准备回收栈和堆上的白色对象时，栈上会STW进行保护，不允许创建删除任何对象。

然后再从根对象进行一次遍历，此时A对象还是引用了B对象，所以两者都会变成黑色，B对象不会被回收。

重新描述一次流程：

1. 栈和堆都从根对象开始，置为灰色，然后向下传播。
    1. 堆存在插入写屏障，所以GC期间，引用新的对象，都会使这个新对象变灰（黑色不会变灰）。
    2. 栈不存在插入写屏障，所以GC期间，引用新的对象，还是原来的颜色。引用一个白色新对象，就还是白色。
2. 标记完成，栈上STW，重新从根对象开始遍历，正确性。

插入写屏障的缺陷是栈需要两次扫描，需要STW，性能差。

### 4.2 删除写屏障

对象引用段开始，触发的机制。

GC期间，当A对象断开对B对象的引用，B对象会标记为灰色。这是弱三色不变性的应用，删除的对象会变灰，这样一个黑色对象就不会引用到任何断开的白色对象，就不会导致悬挂指针。

但是这就导致了一个问题：

1. 在本轮GC中，一个被删除的对象会被置灰（黑色不会变灰），如果它没有被任何根对象引用，是理应被回收的，但是现在它是灰色，就逃过了这一轮的回收。
2. 但是因为这个对象始终是根对象不可达的，所以下一轮中它肯定是白色，会被回收。

删除写屏障的缺陷是回收精度低，一轮可能回收不完所有垃圾。

### 4.3 混合写屏障

1. GC开始，优先扫描栈，把栈上所有对象全部扫描并且把**可达对象**标记为黑色（栈上没有任何屏障，不需要第二次重复扫描，无需STW）
2. GC期间，在栈上创建的任何新对象，都是黑色。
3. 堆中被删除的对象全部标记为灰色（堆上使用屏障）。
4. 堆中被引用的对象全部标记为灰色。

## 5 更多GC方式

1. 引用计数：原理是此对象有一个引用，即增加一个计数，删除一个引用则减少一个计数。垃圾回收时，只用收集计数为 0 的对象，此算法最致命的是无法处理循环引用的问题。

2. 标记-清除：此算法执行分两阶段，第一阶段从引用根节点开始标记所有被引用的对象；第二阶段遍历整个堆，把未标记的对象清除，此算法需要暂停整个应用，同时会产生内存碎片。

3. 复制算法：此算法把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中，此算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现“碎片”问题。当然，此算法的缺点也是很明显的，就是需要两倍内存空间。

4. 标记-整理：此算法结合了“标记-清除”和“复制”两个算法的优点，也是分两阶段，第一阶段从根节点开始标记所有被引用对象；第二阶段遍历整个堆，把清除未标记对象并且把存活对象“压缩”到堆的其中一块，按顺序排放，此算法避免了“标记-清除”的碎片问题，同时也避免了“复制”算法的空间问题。

## 6 什么时候能触发GC？

1. runtime.gc()
2. 每两分钟一次
3. 堆中对象大小为上次GC之后剩余对象大小的两倍