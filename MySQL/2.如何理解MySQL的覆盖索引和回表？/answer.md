# 如何理解MySQL的覆盖索引和回表？

参考：https://zhuanlan.zhihu.com/p/107125866

* [如何理解MySQL的覆盖索引和回表？](#如何理解mysql的覆盖索引和回表)
  * [1 聚簇索引](#1-聚簇索引)
    * [1\.1 聚簇索引是个什么东西？](#11-聚簇索引是个什么东西)
    * [1\.2 聚簇索引有什么特性？](#12-聚簇索引有什么特性)
    * [1\.3 为什么需要聚簇索引？](#13-为什么需要聚簇索引)
  * [2 普通索引](#2-普通索引)
    * [2\.1 普通索引是个什么东西？](#21-普通索引是个什么东西)
    * [2\.2 普通索引有什么特性？](#22-普通索引有什么特性)
  * [3 实际例子](#3-实际例子)
    * [3\.1 准备](#31-准备)
    * [3\.2 聚簇索引结构](#32-聚簇索引结构)
    * [3\.3 通过聚簇索引进行查询](#33-通过聚簇索引进行查询)
    * [3\.4 普通索引结构](#34-普通索引结构)
    * [3\.5 通过普通索引进行查询](#35-通过普通索引进行查询)
      * [第一步](#第一步)
      * [第二步](#第二步)
  * [4 回表](#4-回表)
    * [4\.1 回表的概念](#41-回表的概念)
    * [4\.2 会不会回表？](#42-会不会回表)
    * [4\.3 为啥普通索引的叶子节点要存个聚簇索引的值，而不是像聚簇索引一样存数据行呢？](#43-为啥普通索引的叶子节点要存个聚簇索引的值而不是像聚簇索引一样存数据行呢)
  * [5 索引覆盖，避免回表](#5-索引覆盖避免回表)
    * [5\.1 覆盖索引的概念](#51-覆盖索引的概念)
    * [5\.2 实现覆盖索引](#52-实现覆盖索引)
    * [5\.3 现实中的业务情况](#53-现实中的业务情况)
      * [5\.3\.1 str\_id](#531-str_id)
      * [5\.3\.2 优化str\_id](#532-优化str_id)

## 1 聚簇索引

不能简单把主键理解为聚簇索引哦，虽然一般情况下主键就是聚簇索引。

### 1.1 聚簇索引是个什么东西？

> 如果表设置了主键，则主键就是聚簇索引。  
>
> 如果表没有主键，则会默认第一个NOT NULL，且唯一（UNIQUE）的列作为聚簇索引。  
>
> 以上都没有，则会默认创建一个隐藏的row_id作为聚簇索引。

### 1.2 聚簇索引有什么特性？

> InnoDB的聚簇索引的叶子节点存储的是行记录（其实是页结构，一个页包含多行数据），InnoDB必须要有至少一个聚簇索引。
>
> 由此可见，使用聚簇索引查询会很快，因为可以直接定位到行记录。

总之，一张表可以没有主键，但是一定会有聚簇索引。

### 1.3 为什么需要聚簇索引？

可以反问一下自己，如果没有默认的聚簇索引，会造成什么问题？还能找到数据吗？

> 现在有个表A，里面存了1、2、3数据。现在我希望找到数据1。
>
> 我给出一块连续的磁盘区间，我知道表A就是指向这块区间，所有的数据只要在这块区间里面去找就可以了。于是每次我都把这块的数据从磁盘读到内存，然后遍历找到1。
>
> 但是这很明显是一种理想情况。假如现在表A中需要存1亿个数据，你觉得真的能申请到这么一大块连续的磁盘空间吗？而且我不可能每次都把所有数据都从磁盘读到内存吧，这样内存空间也会吃紧，效率也很差。
>
> 事实上，表A的每个数据，都可能离散在磁盘上的各个区域。假如我现在要做个全表扫描，我要怎么确定A表的数据在哪里呢？
>
> 所以我们肯定需要一种高效的搜索结构，能掌控每个数据在磁盘上的位置。而且我不需要每次都把所有数据加载到内存里面去遍历，我需要精确定位，一击即中。

我个人认为，默认的聚簇索引，其实就是数据库用来确定其内容位置的。没这个东西，你存了数据到哪里去找……

## 2 普通索引

### 2.1 普通索引是个什么东西？

> 普通索引也叫二级索引，除聚簇索引外的索引，即非聚簇索引。
>
> 如果不是聚簇索引，就是普通索引，就那么简单。

### 2.2 普通索引有什么特性？

> InnoDB的普通索引叶子节点存储的是主键（聚簇索引）的值，而MyISAM的普通索引存储的是记录指针。

总之要记住，聚簇索引的叶子节点，存的是数据页，数据页由数据行组成，也就是一行行的记录。普通索引的叶子节点，存的是聚簇索引的值，是一个值！

那么有些小同学要问了，为啥普通索引的叶子节点要存个聚簇索引的值，而不是像聚簇索引一样存数据行呢？

其实这个不是一个能不能的问题，而是一个有没有必要的问题。具体可以看4.3。

## 3 实际例子

### 3.1 准备

建表：

```sql
mysql> create table user(
    -> id int(10) auto_increment,
    -> name varchar(30),
    -> age tinyint(4),
    -> primary key (id),
    -> index idx_age (age)
    -> )engine=innodb charset=utf8mb4;
```

id 字段是聚簇索引，age 字段是普通索引（二级索引）。

填充数据：

```sql
insert into user(name,age) values('test1',30);
insert into user(name,age) values('李四',20);
insert into user(name,age) values('王五',40);
insert into user(name,age) values('刘八',10);

mysql> select * from user;
+----+--------+------+
| id | name  | age |
+----+--------+------+
| 1 | 张三  |  30 |
| 2 | 李四  |  20 |
| 3 | 王五  |  40 |
| 4 | 刘八  |  10 |
+----+--------+------+
```

### 3.2 聚簇索引结构

id 是主键，所以是聚簇索引，其叶子节点存储的是对应行记录的数据。

![](https://brt-1303999354.cos.ap-shanghai.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20210212221635.png)

### 3.3 通过聚簇索引进行查询

```sql
select * from user where id = 1;
```

如果查询条件为主键（聚簇索引），则只需扫描一次B+树即可通过聚簇索引定位到要查找的行记录数据。

![trie-tree](https://brt-1303999354.cos.ap-shanghai.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20210212222245.png)

可以直接找到 ` id=1 ` 的行位置，然后把这行（实际上是页）数据从磁盘加载到内存中，返回结果。

### 3.4 普通索引结构

age 是普通索引（二级索引），非聚簇索引，其叶子节点存储的是聚簇索引的的值。

![trie-tree](https://brt-1303999354.cos.ap-shanghai.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20210212222848.png)

### 3.5 通过普通索引进行查询

```sql
select * from user where age = 30;
```

如果查询条件为普通索引（非聚簇索引），需要扫描两次B+树，第一次扫描通过普通索引定位到聚簇索引的值，然后第二次扫描通过聚簇索引的值定位到要查找的行记录数据。

1. 先通过普通索引 age=30 定位到主键值 id=1。
2. 再通过聚集索引 id=1 定位到行记录数据。


#### 第一步
![trie-tree](https://brt-1303999354.cos.ap-shanghai.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20210212223728.png)

#### 第二步
![trie-tree](https://brt-1303999354.cos.ap-shanghai.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20210212222245.png)

## 4 回表

### 4.1 回表的概念

还记得刚才执行这条语句：

```sql
select * from user where age = 30;
```

使用普通索引的执行过程吗？

1. 先通过普通索引 age=30 定位到主键值 id=1。
2. 再通过聚集索引 id=1 定位到行记录数据。

这就是回表。

先通过普通索引的值定位聚簇索引值，再通过聚簇索引的值定位行记录数据，需要扫描两次索引B+树，它的性能较扫一遍索引树更低。

### 4.2 会不会回表？

那有的小同学就要问了，那我执行这条sql会不会回表呢？

```sql
select age from user where age = 30;
```

答案是不会回表。因为你的查询目标，在普通索引上已经有对应结果，所以不需要再通过聚簇索引再去找一遍。

那么这条呢？

```sql
select id from user where age = 30;
```

也不会回表。还记得普通索引的叶子节点存了什么东西吗？存的就是主键的id，所以也可以直接返回结果。

最后这条呢？

```sql
select name from user where age = 30;
```

会回表。因为name这个字段在普通索引上没有，必须通过聚簇索引拿到行数据，才能拿到name的值。

### 4.3 为啥普通索引的叶子节点要存个聚簇索引的值，而不是像聚簇索引一样存数据行呢？

确实这样不用回表，但是同一个东西为啥要存两个地方呢？

为了一个读体验，毁灭写体验，是得不偿失的。

## 5 索引覆盖，避免回表

### 5.1 覆盖索引的概念

如果实现了索引覆盖，只需要在一棵索引树上就能获取SQL所需的所有列数据，无需回表，速度更快。

### 5.2 实现覆盖索引

比如有这样一条需要回表的sql：

```sql
select id,name,age from user where age = 30;
```

因为age是普通索引，没有name，所以需要回表才能拿到。那么，怎样才能实现索引覆盖呢？

最简单的办法，就是创建联合索引：

```sql
drop index idx_age on user;
create index idx_age_name on user(`age`,`name`);
```

只要查询走了索引，就能一次性拿完全部字段了。

### 5.3 现实中的业务情况

#### 5.3.1 str_id

见过有些同学是这样设计表的：

```sql
mysql> create table user(
    -> id int(10) auto_increment,
    -> str_id varchar(30),
    -> name varchar(30),
    -> age tinyint(4),
    -> primary key (id),
    -> index idx_age (age)
    -> )engine=innodb charset=utf8mb4;
```

一个id是对内的，一个str_id是对外暴露的，然后写这样的sql：

```sql
select * from user where str_id = "str_id";
```

如果没有对str_id建联合索引，那肯定是触发回表了。

就算你对str_id建立了联合索引，假如有一天加了一个字段sex，你写到了sql里面，但是忘记处理索引，那么还是会回表。

如果表的数据量比较少，像这种user表也就不到10w，就算回表也是毫秒级。如果数据量上到100w，甚至是1000w，那么就可能变成秒级，不能接受。

100w数据，你说分表吧，好像也没太大必要，肯定就是搞下覆盖索引就算了。如果是1000w，那肯定就是设计不合理，需要尽快分库分表。

#### 5.3.2 优化str_id

其实，如果可以，还是尽量避免str_id的写法，用聚簇索引去查询，比如用个ID。

那么有的同学就会说了，我们的ID是递增主键，如果暴露出去，岂不是泄露了我们的用户量、业务量了？

确实如此，很多有问题的设计都会存在这样的问题。对此我推荐不要使用递增主键，用分布式ID，比如snowflake算法生成的主键ID。这种ID类似11451419198101145141（一般是十进制共20位？），就可以直接直接暴露。

个人建议可以先设计一套分布式ID，新业务新上，然后老业务慢慢考虑移植问题。这确实很看架构师的水平。