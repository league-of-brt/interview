# MySQL为什么不用二叉树、平衡二叉树、B树，要使用B+树？

* [10 MySQL为什么不用二叉树、平衡二叉树、B树，要使用B\+树？](#10-mysql为什么不用二叉树平衡二叉树b树要使用b树)
  * [1 为什么不用二叉树？](#1-为什么不用二叉树)
  * [2 为什么不用平衡二叉树？](#2-为什么不用平衡二叉树)
  * [3 为什么不用B树？](#3-为什么不用b树)
  * [4 为什么使用B\+树？](#4-为什么使用b树)
  * [5 既然B\+树这么好，为什么MongoDB要使用B树呢？](#5-既然b树这么好为什么mongodb要使用b树呢)
    * [5\.1 简述你对关系型、聚合型数据库的理解？](#51-简述你对关系型聚合型数据库的理解)
    * [5\.2 数据库类型，决定了其使用方式](#52-数据库类型决定了其使用方式)

首先我们要知道，基于硬盘的数据库，比如MySQL，很大一部分性能瓶颈都在于硬盘的IO。为了提高程序的性能，必须尽可能减少硬盘IO次数，所以存储数据的结构必须精妙。

出于常识，我们都知道MySQL使用B+树作为索引结构。那么问题来了，同样是树，为啥二叉树、平衡二叉树、B树就不行？不行在哪里？

再深究一下，既然B+树强于别的树，为啥MongoDB不使用B+树，而是使用B树？是出于什么考量？

大家都知道是因为数据结构的差异导致的，我今天想理清楚这件事情。

参考：
1. https://www.cnblogs.com/kaleidoscope/p/9481991.html
2. http://www.liuzk.com/410.html

## 1 为什么不用二叉树？

![pic](https://brt-1303999354.cos.ap-shanghai.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20210309014719.png)

缺点：
1. 节点限制为2，导致搜索树高度过高，影响查询效率。这里才5个数据，树的高度已经为5，需要进行4次磁盘IO。
2. 因为二叉树的特性，在部分情况下会退化成链表，查询变成全表搜索。如果增加节点顺序为从大到小，即40->5，就会退化为链表。
3. 因为局部性原理（一个数据被访问，其附近的数据也倾向于被访问），数据库有预读机制。但是平衡二叉树距离过于远，比如拿到一个5，那么10、20、30都很有可能被访问，但是我们不能预先就拿完全部数据（定位之前你无法预知什么数据在附近），而是要等定位到5的位置，才能加载附近的一些节点。

## 2 为什么不用平衡二叉树？

![pic](https://brt-1303999354.cos.ap-shanghai.myqcloud.com/184881-20180815151649579-437223668.png)

为了解决搜索二叉树退化的极端情况，人们设计出平衡二叉树。但是依然存在问题。

缺点：
1. 节点限制为2，导致搜索树高度过高，影响查询效率。这里才9个数据，树的高度已经为4，需要进行4次磁盘IO。
2. 既然是平衡二叉树，那么节点的插入和删除都会导致树的平衡操作，平衡二叉树通过旋转节点来维持平衡，旋转是对整棵树的操作。为了维持平衡，需要把整棵树从硬盘加载到内存，进行旋转，再存回硬盘，效率很差。比如现在干掉20，就会让25顶替原来20的位置，此时需要从硬盘加载所有节点信息。
3. 因为空间局部性原理（如果一个存储器的某个位置被访问，那么其附近的位置也倾向于被访问），数据库有预读机制。但是平衡二叉树距离过于远，比如拿到一个4，那么4、7、8、10、14都很有可能被访问，但是我们不能预先就拿完全部数据（定位之前你无法预知什么数据在附近），而是要等定位到4的位置，才能加载附近的一些节点。

## 3 为什么不用B树？

![pic](https://brt-1303999354.cos.ap-shanghai.myqcloud.com/184881-20180815153832038-1145695169.png)

针对平衡二叉树的缺点，人们设计出B树，这次像模像样了。

优点：
1. 针对平衡二叉树节点限制为2，导致搜索树高度过高的问题，B树支持多节点，有效减少树的高度，提高搜索效率。
2. 针对平衡二叉树的平衡操作需要旋转，读取整棵树的问题，B树插入删除后，如果不满足平衡条件，不会进行旋转操作，只会进行分裂和合并操作，把影响的范围限制在了局部，即只需要读取操作部分页。
3. 针对数据库的预读机制，B树优化得也不错。比如要找到35数据，通过二分法可以知道35在30和40之间，那么可以一次性把这些子节点全部加载出来，只需要一次IO。

缺点：
1. B树对范围查询的支持做得不够好，比如查询id>30的数据，就需要进行多次IO。
2. 每个数据页上，指针和数据本身存在一起。这种设计就有利有弊了，比如我找个50，可以在根页通过二分法直接找到，只需要1次IO，或者我找个40，也只需要两次IO。但是，数据本身是非常占用数据页空间的，这就导致每个16K的数据页只能存更少的指针，如果整张表数据量很大，就会导致B树高度增加，增加IO次数，影响查询效率。
3. 因为可能查询到内层节点就返回结果，每次查询时间可能有很大差别，查询的性能可能不够稳定。

## 4 为什么使用B+树？

![pic](https://brt-1303999354.cos.ap-shanghai.myqcloud.com/184881-20180815154933407-1043362261.png)

对于B树的这些问题，再次进行优化。

优点：
1. 针对B树对范围查询的支持做得不够好的问题，B+树的叶子节点在同一高度，有指针相连，形成了有序链表，便于范围查询。比如查询id>55的数据，只需要找到55的tea，再一路向右遍历子节点即可。
2. 针对B树指针和数据存放在一起，导致占用空间的问题，B+树的根节点和内层节点只存指针和主键，数据统一存在叶子节点。这样根节点和内存节点就能存更多指针，支持更多的数据，降低树高度增加的风险。
3. 所有查询都要查找到叶子节点，查询性能稳定。
4. 叶子节点的数据存在一页上，数据库预读的时候可以一次加载一个叶子节点。

## 5 既然B+树这么好，为什么MongoDB要使用B树呢？

没有哪种最好，只是哪种比较适合。使用的数据结构，和数据库类型有关。

1. MySQL，典型的关系型数据库，专注于数据的事务、聚合操作，着重于数据之间的关系。
2. MongoDB，文档型的数据库，数据只是文档，不关心数据之间的关系。MongoDB使用Bson格式保存数据，归属于聚合型数据库。
3. Redis，键值数据库，数据只是键值对，也不关心数据之间的关系。归属于聚合型数据库。

### 5.1 简述你对关系型、聚合型数据库的理解？

为了理解什么是关系型、聚合型，举个例子：

> 假如我们要建立一个电子商务网站，类似淘宝这种将商品销售给用户，那么必须存储用户信息、商品目录、订单、收货地址、账单地址、付款方式等。

我们看下MySQL储存模型：

![pic](https://brt-1303999354.cos.ap-shanghai.myqcloud.com/184881-20180815155615233-1574417710.png)

可以看到，各表之间都存着一些主键，用于和别的表保持关系，比如Orders表就存着CustomerId。实际上，各表，即实体，之间的联系更多和表结构有关，和内容无关。所以表结构和数据是可以分开储存的。

再看下MongoDB储存模型：

![pic](https://brt-1303999354.cos.ap-shanghai.myqcloud.com/184881-20180815155651963-79053378.png)

转化为类似Json的数据格式：

![pic](https://brt-1303999354.cos.ap-shanghai.myqcloud.com/184881-20180815155921118-687292888.png)

可以看到，表结构和数据是聚合的，以Json的形式体现。这种天生的结构和内容聚合在一起的数据，当然是存在一起。

### 5.2 数据库类型，决定了其使用方式

现在我们有个需求：

> 查询一个姓名为Tom的客户的所有订单。

对于关系型数据库，那当然用JOIN来体现关系了：

```sql
SELECT * from order AS o 
LEFT JOIN (
    SELECT id FROM customer WHERE name = 'Tom'
) AS t ON o.customer_id = t.id
WHERE t.id IS NOT NULL
```

假设我们的name和customer_id字段都有索引，那么使用B+树的结构，就能一次性找到所有名叫Tom的顾客，拿到id之后，再一次性拿到所有订单。这里的name和customer_id显然都是起了指针的作用（用于找到实际数据），就很适合使用B+树。

但是对于非关系型数据库，就是这样的一个Json：

```json
//customer
{
	"id": 1,
	"name": "Tom",
	"order_list": [{
		"id": 99
	}, {
		"id": 100
	}]
}
```

对于这种数据，直接执行`db.customer.find({name:'Tom'})`，订单信息就全出来了。反正就是利用索引name，找到指针，值就能读出来，这种单一查询的功能就很适合使用B树。

这就是MongoDB要使用B树的原因。
