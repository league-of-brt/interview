# MySQL InnoDB一棵B+树可以存放多少数据？

* [MySQL InnoDB一棵B\+树可以存放多少数据？](#mysql-innodb一棵b树可以存放多少数据)
  * [1 最小储存单元](#1-最小储存单元)
  * [2 如何通过B\+树进行查询？](#2-如何通过b树进行查询)
  * [3 如何通过B\+树进行查询？（详细版本）](#3-如何通过b树进行查询详细版本)
  * [4 通常一棵B\+树可以存放多少数据？](#4-通常一棵b树可以存放多少数据)
  * [5 为什么索引字段要尽量小？](#5-为什么索引字段要尽量小)
  * [6 为什么b\+树要求把真实的数据放到叶子节点而不是内层节点？](#6-为什么b树要求把真实的数据放到叶子节点而不是内层节点)
  * [7 为什么Innodb不使用B树，要用B\+树？](#7-为什么innodb不使用b树要用b树)

InnoDB一棵B+树可以存放多少行数据？这个问题的简单回答是：约2千万。为什么是这么多呢？因为这是可以算出来的，要搞清楚这个问题，我们先从InnoDB索引数据结构、数据组织方式说起。

参考：
1. https://zhuanlan.zhihu.com/p/355302417
2. https://tech.meituan.com/2014/06/30/mysql-index.html

## 1 最小储存单元

我们都知道计算机在存储数据的时候，有最小存储单元，这就好比我们今天进行现金的流通最小单位是一毛。

在默认情况下：
1. 磁盘存储数据最小单元是扇区，一个扇区的大小是512B。
2. 文件系统（例如XFS/EXT4）的最小单元是块，1块 = 8扇区 = 4096B，即一个块的大小是4KB。
3. InnoDB存储引擎的最小储存单元——页，1页 = 16KB。

因为文件系统有最小储存单元，所以一些文件内容很小，但是依然要占据一个储存单元。

比如一个small-file大小只有1个B，可能就存了一个1/0，但是在文件系统上，他也要占据1个块的容量，要占据4KB。

同理，因为InnoDB的最小储存单元是1页，就算只有一行数据（在1KB左右），也要占据1页，要占据16KB。

InnoDB的数据文件（后缀为ibd的文件）是由页组成的，ibd文件的大小 = 页数 * 页大小，所以ibd大小始终是16KB的整数倍。

所以，假如现在MySQL就存了一行数据，那么计算机上可能会生成一个ibd文件，这个ibd文件由1页组成，大小是16KB。

以上说的全部是默认情况，实际上块、页都是抽象单位，不是物理单位，块 = 几个扇区、页的大小都是可以设置的，所以说如果面试官问你能装多少数据，要问清楚是不是默认情况。

## 2 如何通过B+树进行查询？

数据表中的数据都是存储在页中的，所以一个页中能存储多少行数据呢？假设一行数据的大小是1k，那么一个页可以存放16行这样的数据。

如果数据库只按这样的方式存储，那么如何查找数据就成为一个问题，因为我们不知道要查找的数据存在哪个页中，也不可能把所有的页遍历一遍，那样太慢了。

所以人们想了一个办法，用B+树的方式组织这些数据。如图所示：

![pic](https://brt-1303999354.cos.ap-shanghai.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20210308135008.png)

我们先将数据记录按主键进行排序，分别存放在不同的页中（为了便于理解我们这里一个页中只存放3条记录，实际情况可以存放很多）。

除了存放数据的页以外，还有存放键值 + 指针的页，如图中page number = 3的页，该页存放键值和指向数据页的指针，这样的页由N个键值+指针组成。

现在来看下，要查找一条数据，怎么查？

```sql
select * from user where id = 5;
```

这里id是主键，我们通过这棵B+树来查找，首先找到根页。

那么问题来了，你怎么知道user表的根页在哪呢？

其实根页相当于一棵树的root，我们要找树中的某个节点，肯定是从一棵树的既定的根节点起手去找的。

每张表的根页位置在表空间文件中是固定的，如果我们要查user表，就一定能从一个固定地点拿到根页，即page number = 3的页。

现在我们要找的id=5，在根页进行二分查找，因为5在键值4、7之间，那么能找到指针P5。于是进一步拿到Page5，在页中再次进行二分查找，找到id = 5的数据行。

## 3 如何通过B+树进行查询？（详细版本）

现在来看下，要查找一条数据，怎么查？

```sql
select * from user where id = 29;
```

![pic](https://brt-1303999354.cos.ap-shanghai.myqcloud.com/7af22798.jpg)

浅蓝色的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个数据项（深蓝色所示）和指针（黄色所示），如磁盘块1包含数据项17和35，包含指针P1、P2、P3，P1表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块。

真实的数据存在于叶子节点即3、5、9、10、13、15、28、29、36、60、75、79、90、99。非叶子节点只不存储真实的数据，只存储指引搜索方向的数据项，如17、35并不真实存在于数据表中。

> 1. 如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO。
> 2. 在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针（内存时间因为非常短（相比磁盘的IO）可以忽略不计）。
> 3. 通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO。
> 4. 29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO。
> 5. 同时内存中做二分查找找到29，结束查询，总计三次IO。

3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。

根据我的理解，这里的磁盘块就是页的意思。

## 4 通常一棵B+树可以存放多少数据？

这里我们先假设B+树高为2，即存在一个根节点和若干个叶子节点，那么这棵B+树的存放总记录数为：根节点指针数 * 单个叶子节点记录行数。

首先我们计算出根节点能存放多少指针。

假设主键ID为bigint类型，长度为8字节，而指针大小在InnoDB源码中设置为6字节，加起来成为14字节的指针单元。一页中能存放多少个指针单元，就代表有多少指针。

一页 = 16KB = 16*1024B = 16384B

16384B/14B = 1170

所以根节点能存放1170个指针，指向1170个叶子节点。

假设一行记录的数据大小为1k（实际上现在很多互联网业务数据记录大小通常就是1K左右），每个叶子节点能存的行数 = 16K/1K = 16行。

那么可以算出一棵高度为2的B+树，能存放1170页*16行 = 18720行这样的数据项。

那么高度为3的B+树呢？

根页可以存1170个指针单元，每个指针指向一个二级索引页。每个二级索引页又可以存1170个指针单元，每个指针指向一个数据页（叶子节点），每个数据页又可以存16行数据，就那么就是1170*1170*16 = 21902400行，也就是说高度为3的B+树能存千万级的数据记录。

至此我们可以总结出一个计算公式：

数据行数 = 根页能存的指针单元数 * 二级索引页能存的指针单元数 * 数据页能存的数据行数

B+树的高度等于硬盘IO的次数，所以通过主键索引查询通常只需要1-3次IO操作即可查找到数据。

## 5 为什么索引字段要尽量小？

通过上面的分析，我们知道IO次数取决于b+数的高度h。

假设当前数据表的数据为N，每个磁盘块能存的数据项的数量是m，则有h=㏒(m+1)N，当数据量N一定的情况下，m越大，h越小；

而m = 磁盘块的大小 / 数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。

这就是为什么每个数据项，即索引字段要尽量的小，比如int占4字节，要比bigint8字节少一半。数据项小，单个磁盘块就能存下更多的数据项，不用增加B+树的高度。

总之，索引字段小，指针单元就小，同样大小的数据页就能装下更多的数据，于是树的高度就低。树的高度低，IO次数少，查询快。

## 6 为什么b+树要求把真实的数据放到叶子节点而不是内层节点？

和索引字段同样的道理，一个磁盘块能装下的数据项是有限的，如果把数据放在内存节点，就占用了指针单元的空间，导致树的高度升高，增加IO次数，查询就慢。

## 7 为什么Innodb不使用B树，要用B+树？

这个问题先要看懂B树，可以看看：https://blog.csdn.net/moakun/article/details/79927830

这里先说结论：

1. 单一节点存储更多的元素，使得查询的IO次数更少（B树需要在每个节点都存具体数据，而B+树只在叶子节点存具体数据）。
2. 所有查询都要查找到叶子节点，查询性能稳定（B树查询可能中途就返回，B+树一定要查到叶子节点）。
3. 所有叶子节点形成有序链表，便于范围查询（B树不支持范围查询，B+树叶子节点之间有指针，形成有序链表，支持范围查询）。
