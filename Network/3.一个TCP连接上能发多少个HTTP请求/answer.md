# 一个TCP链接上面能发多少个HTTP请求



参考：https://zhuanlan.zhihu.com/p/61423830

## 1 浏览器在与服务器建立了一个 TCP 链接后，是否会在一个 HTTP 请求完成后断开？什么情况下会断开？

### 1.1 HTTP/1.0 

在 HTTP/1.0 中，一个服务器在接收一个 HTTP 响应后，会断开 TCP 链接。

为啥这样设计呢？

因为 HTTP/1.0 标准是在1996年建立的，在当时 web 技术还不发达，一个页面含有的元素很少，可能就一堆文字和几张图片。就算一个 HTTP 响应对应着一条 TCP 链接的周期，读取一个网页可能也就几个 TCP 链接的问题，而且还能并发，就显得效率没有那么差。

除此之外，当时的服务器也不会承受海量请求，所以就算一个请求对应一条 TCP，只要按时关闭不要长时间持有，服务器压力也不会太大。

后面发生的事情大家都知道了，网页元素越来越丰富，对服务器的请求越来越多，此时人们发现，
每次请求都会重新建立和断开 TCP 链接，代价太大了。

### 1.2 HTTP/1.1

怎么解决呢？

虽然标准中没有设定，但是某些服务器对 Connection: keep-alive 的 Header 进行了支持。

意思是说，**完成这个 HTTP 请求之后，不要断开 HTTP 请求使用的 TCP 链接**。

这样的好处是链接可以被复用，之后发送 HTTP 请求的时候不需要重新建立 TCP 链接。如果维持链接，那么 SSL 的开销也可以避免。

这样多个HTTP请求就可以走同一条 TCP 链接，效率大大提高。

于是，在1999年， HTTP/1.1 就把 Connection 头写进标准，并且默认开启持久链接。

除非请求中写明 Connection: close，那么浏览器和服务器之间是会维持一段时间的 TCP 链接，不会一个请求结束就断掉。

## 2 一个 TCP 链接可以对应几个 HTTP 请求？

了解了第一个问题之后，其实这个问题已经有了答案，如果维持链接，一个 TCP 链接是可以发送多个 HTTP 请求的。

## 3 一个 TCP 链接中 HTTP 请求发送可以一起发送么（比如一起发三个请求，再三个响应一起接收）？

### 3.1 HTTP/1.1

HTTP/1.1 存在一个问题，单个 TCP 链接在同一时刻只能处理一个请求，意思是说：两个请求的生命周期不能重叠，任意两个 HTTP 请求从开始到结束的时间在同一个 TCP 链接里不能重叠。

虽然 HTTP/1.1 规范中规定了 Pipelining 来试图解决这个问题，但是这个功能在浏览器中默认是关闭的。

先来看一下 Pipelining 是什么，RFC 2616 中规定了：

> A client that supports persistent connections MAY "pipeline" its requests (i.e., send multiple requests without waiting for each response). A server MUST send its responses to those requests in the same order that the requests were received.
>
> 一个支持持久链接的客户端可以在一个链接中发送多个请求（不需要等待任意请求的响应）。收到请求的服务器必须按照请求收到的顺序发送响应。

至于标准为什么这么设定，我们可以大概推测一个原因：

由于 HTTP/1.1 是个文本协议，同时返回的内容也并不能区分对应于哪个发送的请求，所以顺序必须维持一致。比如你向服务器发送了两个请求 GET /query?q=A 和 GET /query?q=B，服务器返回了两个结果，浏览器是没有办法根据响应结果来判断响应对应于哪一个请求的。

如果完全按照 Pipelining 的标准去实践，会出现许多问题：

1. Head-of-line Blocking 链接头阻塞：在建立起一个 TCP 链接之后，假设客户端在这个链接连续向服务器发送了几个请求。按照标准，服务器应该按照收到请求的顺序返回结果，假设服务器在处理首个请求时花费了大量时间，那么后面所有的请求都需要等着首个请求结束才能响应。
2. 一些代理服务器不能正确的处理 HTTP Pipelining。Pipelining 要求返回的响应是有顺序的，如果代理服务器不支持顺序，给你随机乱序，就会影响客户端的读取了。
2. 正确的流水线实现是复杂的。详见：https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Connection_management_in_HTTP_1.x#HTTP_%E6%B5%81%E6%B0%B4%E7%BA%BF

因为存在这些问题，所以现代浏览器默认是不开启 HTTP Pipelining 的。

所以我们可以认为，在 HTTP/1.1，一个链接同时发送多个请求是不可行的。

那么，怎么提高页面加载效率呢？

HTTP/1.1 只做到了这两点：

1. 维持和服务器已经建立的 TCP 链接，在同一链接上顺序处理多个请求。
2. 和服务器建立多个 TCP 链接。

### 3.2 HTTP/2.0

HTTP2 提供了 Multiplexing 多路传输特性，可以在一个 TCP 链接中同时完成多个 HTTP 请求。

具体实现可以参考：https://www.kancloud.cn/digest/web-performance-http2/74825

## 4 为什么有的时候刷新页面不需要重新建立 SSL 链接？

这里需要先弄清楚一个概念，既然提到了 SSL 链接，那么上层肯定就是 HTTPS 协议，他们是这样的依赖顺序：HTTPS -> SSL/TTL -> TCP。

在前面的问题中，我们知道 TCP 链接有时候会被浏览器和服务端维持一段时间。TCP 不需要重新建立，SSL 自然也会用之前的。

## 5 浏览器对同一 Host 建立 TCP 链接到数量有没有限制？

假设我们还处在 HTTP/1.1 时代，那个时候没有多路传输，当浏览器拿到一个有几十张图片的网页该怎么办呢？肯定不能只开一个 TCP 链接顺序下载，那样用户肯定等的很难受，但是如果每个图片都开一个 TCP 链接发 HTTP 请求，那电脑或者服务器都可能受不了，要是有 1000 张图片的话总不能开 1000 个TCP 链接吧，你的电脑同意 NAT 也不一定会同意。

所以答案是：有。Chrome 最多允许对同一个 Host 建立六个 TCP 链接。

不同的浏览器有一些区别：https://developers.google.com/web/tools/chrome-devtools/network/issues#queued-or-stalled-requests

## 6 收到的 HTML 如果包含几十个图片标签，这些图片是以什么方式、什么顺序、建立了多少链接、使用什么协议被下载下来的呢？

如果图片都是 HTTPS 链接并且在同一个域名下（HTTP2强制使用HTTPS），那么浏览器在 SSL 握手之后会和服务器商量能不能用 HTTP2，如果能的话就使用 Multiplexing 功能在这个链接上进行多路传输。

不过也未必会所有挂在这个域名的资源都会使用一个 TCP 链接去获取，但是可以确定的是 Multiplexing 很可能会被用到。

如果发现用不了 HTTP2 呢？或者用不了 HTTPS（现实中的 HTTP2 都是在 HTTPS 上实现的，所以也就是只能使用 HTTP/1.1）？

那浏览器就会在一个 HOST 上建立多个 TCP 链接，链接数量的最大限制取决于浏览器设置，这些链接会在空闲的时候被浏览器用来发送新的请求，如果所有的链接都正在发送请求呢？那其他的请求就只能等等了。

## 7 实践案例

拿淘宝的图片域名服务举个例子：

参考：https://www.zhihu.com/question/36514327/answer/1604554133

上面提到，Chrome 最多允许对同一个 Host 建立六个 TCP 链接，但是淘宝一个页面动不动就三十张图片文件，平均下来每个六条链接每条要处理差不多五个请求，而且每条链接只能依次去处理一条请求。因为是阻塞的，这肯定会影响页面渲染的速度，从而影响用户体验。

对此，淘宝的解决方案是申请多个图片域名，每个域名都是不同的HOST，然后尽量让每个页面的图片分散到每个HOST上。

这样浏览器就能针对多个域名开更多的 TCP 链接，这就加快了 HTTP 的并发数量。
