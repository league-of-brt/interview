## 题目

_描述_

| uid | login time | logout time |
| :---- | :---- | :---- |
| uid1 | 00:00:01 | 00:00:10 |
| uid2 | 00:00:02 | 00:00:05 |
| uid3 | 00:00:03 | 00:00:05 |
 

* linux命令厉害的可以直接 cat 1.log|awk '{print $1}'|sort|uniq -c|sort -n
一般情况下不推荐这种, 因为 sort 和 uniq -c 在大数据量下会性能不高. 而且命令记不住

* Bitmap 位图去存储每个用户在线的每一秒, 如果在线则为1, 不在线则为0. 如果一个用户一整天在线,则位图的长度
为86400. 去遍历位图就有86400次,那100个人一整天都在线的话,去遍历位图就有8640000次

* 拆分思想, 一天分为24小时,先找出小时中的峰值 -> 分钟的峰值 -> 秒的峰值
但是如果同时存在多个峰值,则计算量也比较大, 性能不高

* 时间线思想, 所有在 00:00:03 - 00:00:03  时间点之前登入的 直到 在这个时间点之前所有登出的 

    1. 定义三个变量，其中一个记录当前在线人数（currentVal）,一个最大值（maxVal），最后一个记录其对应的秒数的数组(seconds)。
    2. 将日志分成 登录，登出 两种状态，并且根据时间进行正向排序
    3. 遍历步骤2得到的日志，如果是登录则 currentVal + 1 并且跟 maxVal 对比，如果比 maxVal 大，则将 maxVal 设置为 currentVal, seconds 设置为 当前秒数， 如果 maxVal == currentVal, 则 seconds 增加当前秒数。如果是登出，则 currentVal - 1 （不过更完美点应该判断下当前是不是maxVal, 如果是则将上一次峰值的秒数，到当前秒数的区间写入到 seconds）遍历完成之后得到的 maxVal 就是 峰值， seconds 就是对应的秒数列表

| uid | action | time |
| :---- | :---- | :---- |
| uid1 | 登入 | 00:00:01 |
| uid2 | 登入 | 00:00:02 |
| uid3 | 登入 | 00:00:03 |
| uid2 | 登出 | 00:00:05 |
| uid3 | 登出 | 00:00:05 |
| uid1 | 登出 | 00:00:10 |

思考下上述方法中哪一步骤存在性能问题, 步骤2中根据时间进行正向的排序 O(nlogn).  有没有方法是可以不用进行步骤二的呢??

* 日志不用拆分，处理每条日志的时候，首先是处理登入，直接把峰值加1，如果超过历史峰值则更新历史峰值
   * 接下来处理这条日志的登出，可以开一个86400大小的数组，记录每一秒的登出数，在处理到这个登出时间点时，就减去相应的在线人数