# 简单谈谈怎么实现malloc内存分配

* [简单谈谈怎么实现malloc内存分配](#简单谈谈怎么实现malloc内存分配)
  * [1 程序员如何看待内存](#1-程序员如何看待内存)
  * [2 内存管理会遇到的问题](#2-内存管理会遇到的问题)
  * [3 解决这些问题](#3-解决这些问题)
    * [3\.1 内存分块](#31-内存分块)
    * [3\.2 怎么找到下一段内存块？](#32-怎么找到下一段内存块)
    * [3\.3 怎样选择空闲内存块](#33-怎样选择空闲内存块)
    * [3\.4 避免内存浪费](#34-避免内存浪费)
    * [3\.5 释放内存](#35-释放内存)
    * [3\.6 高效合并内存块](#36-高效合并内存块)

实现两个方法：
1. malloc，也就是如果有人向我申请一块内存，我该怎样从堆区这片区域中找到一块返回给申请者。
2. free，也就是当某一块内存使用完毕后，我该怎样还给堆区这片区域。

## 1 程序员如何看待内存

程序员很少去关心内存分配的问题。作为程序员，可以简单的认为我们的程序独占内存

可以简单认为程序运行起来后，内存结构是这样的：
1. 栈区
2. 文件映射区
3. 堆区
4. 数据区
5. 代码区

从内存分配器的角度看，内存分配器根本不管你是整数、浮点数、链表、二叉树等数据结构、还是对象、结构体等这些花哨的概念，在内存分配器眼里不过就是一个内存块，这些内存块中可以装入原生的字节序列，申请者拿到该内存块后可以塑造成整数、浮点数、链表、二叉树等数据结构以及对象、结构体等。

## 2 内存管理会遇到的问题

实际上你可以把内存看做一条长长的停车场，我们申请内存就是要找到一块停车位，释放内存就是把车开走让出停车位。

那么我们实际上可能遇到哪些个物理问题呢？

1. 停车场这么一大块，不能乱停车吧，得划分各种大小的停车位，管理起来。
2. 我怎么知道一个停车位有多大？
3. 我怎么知道一个停车位现在停了车没有？
4. 我一个停货车的停车位，现在停了一台单车，就标记为被占用了，不合适吧？
5. 有台车来了，我怎么快速地找到大小适合的一个停车位。
6. 如果来了台单车，要停在一个货车车位，我能不能再对这个车位进行划分，多停两台车。
7. 这台单车走了，我需不需要把这个货车车位还原。
8. 马上还原，还是等有货车来的时候再还原？
9. 怎么还原？
10. 两台车要同时占用一个停车位，不合适吧？

翻译过来就变成了：

1. 如何把内存分段。
2. 怎么知道分段内存的大小。
3. 怎么知道一段内存是否被使用。
4. 怎么尽可能地利用内存，比如16KB的数据，正好分配一段16KB的内存。分配多了就浪费了。
5. 怎么快速地找到大小适合的空闲内存。
6. 如果分配的内存块比实际需要的要多，能否再有效细分内存块。
7. 释放内存块，是否需要合并。
8. 积极合并还是惰性合并。
9. 如何合并。
10. 线程安全。

## 3 解决这些问题

### 3.1 内存分块

使用header标记内存，假设内存块大小上限为2G，因此我们可以使用31个比特位来记录块大小，剩下的一个比特位用来标识该内存块是空闲的还是已经被分配出去了。

也就是说，32个bit就能标记一段内存，也就是heade需要4个byte。

### 3.2 怎么找到下一段内存块？

通过header我们就能知道每一个内存块的大小，从而可以很方便的遍历整个堆区。遍历方法很简单，因为我们知道每一块的大小，那么从当前的位置加上当前块的大小就是下一个内存块的起始位置。

### 3.3 怎样选择空闲内存块

1. First Fit
2. Next Fit
3. Best Fit

### 3.4 避免内存浪费

现在我们找到合适的空闲内存块了，接下来我们又将面临一个新的问题。

如果用户需要12字节，而我们的空闲内存块也恰好是12字节，那么很好，直接返回就可以了。

但是，如果用户申请12字节内存，而我们找到的空闲内存块大小为32字节，那么我们是要将这32字节的整个空闲内存块标记为已分配吗？

1. 直接分配。这样虽然速度最快，但显然会浪费内存，形成内部碎片，也就是说该内存块剩下的空间将无法被利用到。

2. 再分配一个新内存块。一种显而易见的方法就是将空闲内存块进行划分，前一部分设置为已分配，返回给内存申请者使用，后一部分变为一个新的空闲内存块，只不过大小会更小而已。

### 3.5 释放内存

释放内存时不需要指定大小，原因很简单，因为我们从要释放的指针地址上移就能知道该内存块的所有信息。

要考虑到的关键一点就在于，与被释放的内存块相邻的内存块可能也是空闲的。那么就有这样的操作：

1. 不合并，那么就得到两个小的内存块。
2. 合并，那么得到一个大的内存块。

不合并可能就会有这样的问题：
1. 来了大量的数据，两个小内存块都装不下。
2. 临时去合并两个小内存块，malloc方法更耗时。

合并可能就会有这样的问题：
1. 马上合并？每次free都去检查相邻的内存块，free方法更耗时。
2. 延迟合并？推迟到下一次分配内存找不到满足要的空闲内存块时再合并相邻空闲内存块。malloc方法更耗时。

还有这样的情况，我频繁释放，再申请同样大小的内存块：
1. 申请12字节大小的内存块
2. 释放
3. 再申请12字节大小的内存块
4. 再释放...

如果没有延迟合并，那么内存分配器会有很多的无用功。

### 3.6 高效合并内存块

因为header，我们是从上往下遍历。假如使用的内存块其前和其后都是空闲的，在当前的设计中我们可以很容易的知道后一个内存块是空闲的，因为我们只需要从当前位置向下移动16字节就是下一个内存块，但我们怎么能知道上一个内存块是不是空闲的呢？

我们之所以能向后跳是因为当前内存块的大小是知道的，那么我们该怎么向前跳找到上一个内存块呢？

我们之所以不能往前跳是因为不知道前一个内存块的信息，那么我们该怎么快速知道前一个内存块的信息呢？

我们不是有一个信息头header吗，那么我们就在该内存块的末尾再加一个信息尾，footer，footer一词用的很形象，header和footer的内容是一样的。

因为上一内存块的footer和下一个内存块的header是相邻的，因此我们只需要在当前内存块的位置向上移动4直接就可以等到上一个内存块的信息，这样当我们释放内存时就可以快速的进行相邻空闲内存块的合并了。
