# 谈谈你对CAS的理解

## 1 CAS 的底层实现

> CAS 是利用了 `锁总线` 或者 `CPU 之间的缓存一致性协议` 实现的。

现在都是多核 CPU 处理器，每个 CPU 处理器内维护了一块字节的内存，每个内核内部维护着一块字节的缓存，当多线程并发读写时，就会出现缓存数据不一致的情况。

假设两个核同时去 CAS 操作一个对象，本应该是一个操作成功，另一个操作失败的。假如同步没做好，很可能会导致 核A 写内存写到一半，核B 修改内存完成，然后 核A 再去覆盖 核B 的结果。这就导致两个写操作都成功，但是数值不正确。

为了同步数据，有两种措施。

### 1.1 总线锁定

当一个处理器要操作共享变量时，在 BUS 总线（另一说是北桥信号，性能更优）上发出一个 Lock 指令，其他处理就无法操作这个共享变量了。

缺点很明显，总线锁定在阻塞其它处理器获取该共享变量的操作请求时，也可能会导致大量阻塞，从而增加系统的性能开销。

### 1.2 缓存锁定

后来的处理器都提供了缓存锁定机制，也就说当某个处理器对缓存中的共享变量进行了操作，其他处理器会有个嗅探机制，将其他处理器的该共享变量的缓存失效。

这里需要看看这篇文章，讲述了 CPU 做了什么：https://yemablog.com/posts/cache-locking

> 当两个 core 同时执行针对同一地址的 CAS 指令时，其实他们是在试图修改每个 core 自己持有的 cache line，假设两个 core 都持有相同地址对应 cache line，且各自 cache line 状态为 S，这时如果要想成功修改，就首先需要把 S 转为 E 或者 M，则需要向其它 core invalidate 这个地址的 cache line，则两个 core 都会向 ring bus 发出 invalidate 这个操作，那么在 ring bus 上就会根据特定的设计协议仲裁是 core0，还是 core1 能赢得这个 invalidate，胜者完成操作，失败者需要接受结果，invalidate 自己对应的 cache line，再读取胜者修改后的值，回到起点。

也就是说，允许两个核的两次 CAS 操作并行，但是每一次 CAS的修改 都要各个核统一意见。一定是只有一个 CAS 修改完成，第二个 CAS 读取新值去执行。

注意有如下两种情况处理器不会使用缓存锁定：

1. 当操作的数据跨多个缓存行，或没被缓存在处理器内部，则处理器会使用总线锁定。

2. 有些处理器不支持缓存锁定，比如：Intel 486 和 Pentium 处理器也会调用总线锁定。