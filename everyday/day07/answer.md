# 简单谈谈你对数据库事务ACID的理解？

## 1.ACID分别是什么？

事务的属性。

<font color="red">**建议一定要记一下单词。**</font>

### 1.1 A（Atomicity） 原子性

- 事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。
- 事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。
- 反正记住，原子性就是强调事务是一个整体。你翻译成整体性，我觉得也不是不可以。

### 1.2 C（Consistency） 一致性

- 一致性是指事务执行前后，数据处于一种合法的状态，也就是整个事务执行下来，是你要的结果，是正确的结果。所以我觉得这个东西叫正确性也可以。
- 一致性，我觉得是业务层面的一种要求。你对数据库进行操作，你当然希望操作的结果符合你的预期，是可靠的。实际上ACID中，AID都是为了实现这个C，与其说C是性质，还不如说C是最终目的。

### 1.3 I（Isolation） 隔离性

- 首先要记住，隔离性，是出于并发的需要。
- 如果你的数据库是神级数据库，一次只能执行一个事务，那你的数据库就实现了完美的隔离性，因为没有并发，就没有并发问题。
- 隔离性是指多个事务并发执行的时候，事务内部的操作与其他事务是隔离的，并发执行的各个事务之间不能互相干扰。
- 隔离性也是ACID中最常考的。从情景模拟，到实现原理，都要深究。

### 1.3 D（Durability） 持久性

- 事务对数据库的改变应该是永久性的，故障不应该对其有任何影响。
- 在业务上，你当然是希望你的事务能够正常改变数据，而且这个结果是能保持的。不能说过一会你的操作根本没有生效，或者正常提交之后又回滚了。

## 2.如果事务没有ACID，会发生什么？

<font color="red">**这里强调一句，这些场景需要牢记。**</font>

从A账户（200）转账50到B账户（0）。

我们探讨一下，如果失去ACID中任一性质，会发生什么。

正常的一个事务：

| 事务1 | 硬盘 | 内存 |
| ---- | ---- | ---- |
| 事务开始 | A=200, B=0 |
| 从磁盘上把A账户余额读取到内存的变量a中 | | a=200 |
| 执行操作：a = a - 50 | | a=150 |
| 把内存中的变量a写回磁盘 | A=150, B=0 |
| 从磁盘上把B账户余额读取到内存的变量b中 | | b=0 |
| 执行操作：b = b + 50 | | b=50 |
| 把内存中的变量b写回磁盘 | A=150, B=50 |
| 事务提交 | 

### 2.1 失去A

#### 2.1.1 事务中途出错，依然能够提交

| 事务1 | 硬盘 | 内存 |
| ---- | ---- | ---- |
| 事务开始 | A=200, B=0 |
| 从磁盘上把A账户余额读取到内存的变量a中 | | a=200 |
| 执行操作：a = a - 50 | | a=150 |
| 把内存中的变量a写回磁盘 | A=150, B=0 |
| -------- 芜湖，没了！|
| 事务提交 | 

整个事务完成了，A平白无故少了50块钱，B没收到钱。

#### 2.1.2 事务中途出现了错误，但是回滚又不正确

| 事务1 | 硬盘 | 内存 |
| ---- | ---- | ---- |
| 事务开始 | A=200，B=0 |
| 从磁盘上把A账户余额读取到内存的变量a中 | | a=200 |
| 执行操作：a = a - 50 | | a=150 |
| 把内存中的变量a写回磁盘 | A=150, B=0 |
| 从磁盘上把B账户余额读取到内存的变量b中 | | b=0 |
| 执行操作：b = b + 50 | | b=50 |
| -------- 芜湖，程序报了个错！|
| 回滚：b = b - 50 | | b=0 |
| 回滚：a = a + 50 失败了！| | a=150 |
| 把内存中的变量b写回磁盘 | A=150, B=0 |
| 事务提交 | 

事务回滚了，但是结果是错误的。

### 2.2 失去C

这个之前也说了，C可以看做是AID的终极目标，没有C就是整个事务执行的结果不符合预期，这个就没什么好举例的了。

### 2.3 失去I

会有并发问题，大家都知道这里会遇到几个经典场景：
- 脏读
- 幻读
- 不可重复读

这里为了简单，只展示一个错误例子。具体内容会在事务的隔离级别专题中详解。

- 第一步，从A账户（200）转账50到B账户（0）。
- 第二步，再从A账户（150）转账50到B账户（50）。

<font color="red">**这里是错误场景！**</font>

| 事务1 | 事务2 | 硬盘 | 内存 |
| ---- | ---- | ---- | ---- |
| 事务开始 | 事务开始 | A=200, B=0 |
| 从磁盘上把A账户余额读取到内存的变量a1中 | | | a1=200 |
| 执行操作：a1 = a1 - 50 | | | a1=150 |
| 把内存中的变量a1写回磁盘 | | A=150, B=0 |
| 从磁盘上把B账户余额读取到内存的变量b1中 | | | b1=0 |
| 执行操作：b1 = b1 + 50 | | | b1=50 |
|  | 从磁盘上把A账户余额读取到内存的变量a2中 | | a2=150 |
|  | 执行操作：a2 = a2 - 50 | | a2=100 |
|  | 把内存中的变量a2写回磁盘 | A=100, B=0 |
|  | 从磁盘上把B账户余额读取到内存的变量b2中 | | b2=0 |
|  | 执行操作：b2 = b2 + 50 | | b2=50 |
|  | 把内存中的变量b2写回磁盘 | A=100, B=50 |
| 把内存中的变量b1写回磁盘 | | A=100, B=50 |
| 事务提交 | 事务提交 |

预期结果是A=100，B=100，结果却是A=100, B=50。

聪明的小伙伴应该知道，对于共享资源，一般用锁来解决问题。在这里，mysql是怎么做的呢？

### 2.3 失去D

最经典的场景就是断电。

| 事务1 | 硬盘 | 内存 |
| ---- | ---- | ---- |
| 事务开始 | A=200，, =0 |
| 从磁盘上把A账户余额读取到内存的变量a中 | | a=200 |
| 执行操作：a = a - 50 | | a=150 |
| 把内存中的变量a写回磁盘 | A=150, B=0 |
| 从磁盘上把B账户余额读取到内存的变量b中 | | b=0 |
| 执行操作：b = b + 50 | | b=50 |
| -------- 芜湖，断电了！|
| 断电内存清空了！无法把b写回磁盘里！ | A=150, B=0 |
| 事务提交 |

这里肯定不能把事务提交了，只能回滚。那么问题来了，数据库怎么知道该提交还是回滚呢？

## 3.如何实现事务的ACID？

以mysql的Innodb举例。

这是一个非常大的话题，我总结如下，请务必记住这个技术图谱：

| | A | C | I | D |
| ---- | ---- | ----| ---- | ---- | 
| 1 | undo log |
| 2 | | A、I、D |
| 3 | |  | 锁机制、悲观锁和乐观锁、隔离级别、MVCC |
| 4 | | | | redo log |

### 3.1 A

通过undo log实现。简单来说，undo log就是操作的反向，专门用于数据的回滚。

### 3.2 C

事务追求的最终目标，一致性的实现即需要数据库层面的保障，也需要应用层面的保障。

### 3.3 I

- 首先需要了解事务的隔离级别，并且明白各个隔离级别下，可能会发生什么问题。
- mysql通过锁来实现事务的隔离级别。
- 区分悲观锁和乐观锁。
- 理解悲观锁通过mysql提供的锁机制来实现。
- 理解乐观锁通过MVCC来实现。

### 3.4 D

通过redo log实现。简单来说，redo log保存了临时数据。mysql修改数据时，同时写内存、磁盘上的redo log，和磁盘。

### 3.5补充

这里提一嘴，有兴趣的同学可以再去了解一下bin log。
