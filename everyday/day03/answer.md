# MySQL锁机制探讨
前提： MySQL8.0 InnoDB
参考书籍：MySQL技术内幕InnoDB存储引擎

## 1、锁机制、锁粒度

### 锁概念
InnoDB中存在两种锁概念：lock、latch
#### lock
通常情况下，我们讲的数据库锁就是指lock
- lock的对象
  - 事务，用来锁定的是数据库中的对象，如：表、页、行
  
- lock持续时间
  - 整个事务过程，一般lock的对象仅在事务commit或rollback后释放
  
- lock的模式
  - 行锁（InnoDB默认级别）
  - 表锁（MyISAM默认级别）
  - 意向锁（为了实现同时支持行锁和表锁）
    
##### 行锁
- 锁类型
  - 共享锁（S Lock），允许事务读一行数据
  - 排他锁（X Lock），允许事务删除或更新一行数据
- 锁算法（排查死锁时会看到算法名相关的字眼，如果要搞清楚为什么死锁就得去了解锁算法）
  - Record Lock
  - Gap Lock
  - Next-Key Lock
  
##### 表锁
InnoDB默认使用的锁粒度为行锁，在未使用索引字段查询（全表查询）时升级为表锁。
如果MySQL认为全表扫描效率更高，它就不会使用索引，这种情况下InnoDB将使用表锁，而不是行锁。(不会用到索引的例子: 枚举列,加索引,因量大,要回表,所以全表快,不用索引)
- 锁类型
  - 共享锁（S Lock），允许事务读某张表中的数据
  - 排他锁（X Lock），允许事务删除或更新某张表中的数据
  
##### 意向锁
- 锁类型
  - 意向共享锁（IS Lock），事务想要获取一张表某几行的共享锁，可看作表级锁
  - 意向排他锁（IX Lock），事务想要获取一张表某几行的排他锁，可看作表级锁
- 作用
  - 事务A取得表foo的行排他锁，事务B想获取表foo的共享锁    
    ``` 
    需满足两个条件：    
      1.无其他事务持有表foo的排他锁    
      2.无其他事务持有表foo任意一行的排他锁    
    由于条件2，无意向锁时，则需要遍历表foo所有行是否有行排他锁；有意向锁时，直接判断表foo是否有意向排他锁  
    ```
看到这里需要补习一下锁排斥情况   
  
**行锁/表锁**
|  | 共享锁(S) | 排他锁(X) |
| --- | --- | --- |
| **共享锁(S)** | 兼容 | 互斥 |     
| **排他锁(X)** | 互斥 | 互斥 |

**表锁与意向锁**
|  | 意向共享锁(IS) | 意向排他锁(IX) |
| --- | --- | --- |
| **共享锁(S)** | 兼容 | 互斥 |     
| **排他锁(X)** | 互斥 | 互斥 |

**意向锁与意向锁**
|  | 意向共享锁(IS) | 意向排他锁(IX) |
| --- | --- | --- |
| **意向共享锁(IS)** | 兼容 | 兼容 |     
| **意向排他锁(IX)** | 兼容 | 兼容 |
    
#### latch
latch称为闩锁，要求锁定时间非常短，其目的是用来保证并发线程操作临界资源（暂不深入）
- latch的对象
  - 线程
- latch持续时间
  - 临界资源


## 2、讲清楚一条insert、select语句的锁使用情况
前提：事务隔离级别为可重复读（其他隔离级别暂不探讨）  
看到这里其实又需要补习一波事务隔离级别、索引原理、快照读/当前读  
快照读（不加锁,Serializable隔离级别加锁）：单纯的select 
当前读（加锁）：update、delete、select for update

```
select * from foo where id=1;  
使用快照，不加锁
```
```
update foo set name='jack' where id=1;  
id为主键，故需要获取表foo的意向排他锁，id=1行排他锁  
id不为主键且无索引，故触发全表扫描，需要表foo意向排他锁、表foo排他锁
```



## 3、常见死锁场景或sql，如何避免
这个问题要分析清楚，需要了解锁的算法  
理论上并发insert就可能造成死锁
TODO 待完善
```
insert into foo(id,name) value(1,'jack') on duplicate key update name=values(name)
```




